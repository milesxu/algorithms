1. 定义在类中的函数默认是内联的。
2. 定义一个默认构造函数就杜绝了一个类型包含未初始化的变量的可能性。
3. 当使用一个 {} 列表时，编译器会创建一个 std::initializer_list 类型。所以可以用此类型当做构造函数等函数的参数。
4. RAII 就是用构造函数分配资源，而用析构函数释放资源。
4. 一个为多种其他类提供接口的类，经常被称作多态类型（polymorphic type）。
5. 通常虚拟类没有构造函数。毕竟，它没有任何需要初始化的数据。同样地，有一个虚拟的析构函数。
6. 接口类必须包含足够的信息，使其在运行时选择正确的函数来调用。通常的实现手法是让编译器将虚函数的名称转化为一个函数指针的表中的索引。该表被称为虚函数表或者 vtbl。每个有虚函数的类都拥有各自的 vtbl 来标识其虚函数。
7. vtbl 中的函数可以被正确使用，即使是在被使用的对象的大小和其数据布局对于被调用者未知的情况下。调用者的实现仅需要知道接口类的 vtbl 中的指针以及每个虚函数的索引。
8. 有继承关系的类的主要的使用方法是指针或引用，而且使用 new 将其实例放在自由存储空间（free store）。
9. 一个函数返回在自由存储空间上分配的对象的指针是很危险的。一个解决方案是返回 unique_ptr。
10. copy constructor, copy assignment, move constructor, move assignment
11. rvalue 就是不能赋值的那些变量之类的。
12. 程序员可以显示地用 std::move 函数来移动变量，在编译器不知道的时候。
13. 在一个层级结构中使用类的默认的 copy 或 move 方法通常会造成灾难：仅仅给定一个基类的指针，我们无法获悉派生类拥有哪些成员，所以我们无法知道如何拷贝它们。所以最好的办法是（在基类中）对与这两类操作关联的方法加上 =delete 后缀。
14. 当用户显式地声明了一个析构函数时，move 操作不会隐式地生成。所以显式地定义析构函数很好。
15. 如果希望用 range-for loop，自定义的类必须有 begin() 和 end() 函数。
16. Function Object，先初始化，然后通过重载的 () 操作符调用。可以和 template 联用，和 lambda 同理。
17. template 的参数数量也可以是可变的
18. 类似 typedef 那样的别名可以用 using 语句。using 可以用来绑定一个 template，然后生成新的 template。
19. 实现继承：共享父类的功能，简化实现开销；接口继承：允许不同的派生类通过共同的基类接口而可互换地被利用。接口继承又称为运行时多态。相对地，通过 template 提供的对多个类的统一使用经常称为编译时多态。